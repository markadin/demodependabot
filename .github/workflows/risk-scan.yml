# ---------------------------------------------------------------------------
# SBOM & Risk Report (Dependabot-only)
#
# Purpose
#   Generates a complete Software Bill of Materials (SBOM) and a vulnerability
#   risk summary for every Dependabot pull request. The workflow posts a
#   detailed PR comment containing:
#     ‚Ä¢ A severity summary (Critical / High / Medium / Low)
#     ‚Ä¢ A table of Critical vulnerabilities with fix versions
#     ‚Ä¢ A readable dependency update diff (old ‚Üí new versions), always computed
#       against the PR base branch (e.g., main), even if Dependabot rebases or
#       refreshes its own branch.
#     ‚Ä¢ A compact SBOM preview (first 100 unique components)
#   It also uploads full machine-readable artifacts (SBOM + vulnerability scan).
#
# Why
#   This provides an audit-ready view of each dependency update (SOUP change)
#   directly inside the PR. According to GitHub‚Äôs documentation, Dependabot
#   version-update PRs are generated according to the ecosystems, directories,
#   and grouping rules specified in dependabot.yml, enabling maintainers to
#   inspect updates before merging.  [2](https://github.blog/changelog/2024-06-25-simplified-dependabot-yml-configuration-with-multi-directory-key-directories-and-wildcard-glob-support/)
#
#   The workflow ensures dependency changes are:
#     ‚Ä¢ Analyzed consistently
#     ‚Ä¢ Documented clearly
#     ‚Ä¢ Supported by artifacts suitable for Quality/Regulatory records
#
# When it runs
#   ‚Ä¢ Automatically for pull requests created/updated by Dependabot only.
#   ‚Ä¢ It does NOT run for developer PRs to keep CI fast and focused.
#   ‚Ä¢ It never fails the PR (non-blocking by design).
#
# How it works (high level)
#   1) Syft generates a CycloneDX SBOM (sbom.json) of the repository contents.  [3](https://sjramblings.io/github-actions-resource-not-accessible-by-integration/)
#   2) Grype scans the SBOM and produces a vulnerability report (grype.json).    [4](https://oss.anchore.com/docs/installation/syft/)
#   3) The workflow computes:
#        - Severity distribution
#        - Critical vulnerability table
#        - Dependency update diff using the PR base SHA ‚Üí head SHA, ensuring
#          correct diffs even after Dependabot rebase/update events
#        - Deduplicated SBOM preview (unique component@version pairs)
#   4) Posts a Markdown report as a PR comment.
#   5) Uploads artifacts (SBOM, vulnerabilities, final comment) for audit.
#
# Inputs & outputs (artifacts)
#   ‚Ä¢ Inputs: The PR‚Äôs dependency changes (manifest/lockfile updates)
#   ‚Ä¢ Output artifacts:
#       - sbom.json
#       - grype.json
#       - report.md
#
# Triggers & scope control
#   ‚Ä¢ Trigger: on: pull_request
#   ‚Ä¢ Guard: job only runs when PR author == dependabot[bot]
#   ‚Ä¢ Optional manual trigger via workflow_dispatch (skips unless Dependabot PR)
#
# Permissions (least privilege)
#   ‚Ä¢ contents: read        ‚Äì fetch repository contents
#   ‚Ä¢ issues: write         ‚Äì post PR comment (PRs are Issues in GitHub API) [4](https://oss.anchore.com/docs/installation/syft/)
#   ‚Ä¢ pull-requests: write  ‚Äì allow safe PR interactions
#
# Policy behavior (non-blocking)
#   ‚Ä¢ The workflow never fails the PR.
#   ‚Ä¢ If later required, a fail-gate step can be added (recommended: only for
#     developer PRs, not Dependabot PRs).
#
# How to run Dependabot on demand
#   ‚Ä¢ Insights ‚Üí Dependency Graph ‚Üí Dependabot ‚Üí Recent update jobs ‚Üí
#     ‚ÄúCheck for updates‚Äù (runs Dependabot version-update job).  
#   ‚Ä¢ Or temporarily change schedule in dependabot.yml to `daily`, commit, then
#     switch back to `weekly`.
#   ‚Ä¢ Or run this workflow manually.
#
# Team expectations
#   ‚Ä¢ Review ‚Äúüì¶ Dependency Updates‚Äù for old ‚Üí new versions
#   ‚Ä¢ Review ‚Äú‚ùó Critical Vulnerabilities‚Äù for security implications
#   ‚Ä¢ Review severity table and SBOM preview
#   ‚Ä¢ Download artifacts for deeper analysis or SOUP records
#
# Troubleshooting
#   ‚Ä¢ Missing dependency updates:
#       Dependabot may have rebased; diff uses base.sha ‚Üí head.sha to ensure
#       correct results regardless of Dependabot rebasing.
#   ‚Ä¢ Resource not accessible: check permissions include issues:write and
#       pull-requests:write.  [5](https://dev.to/arbythecoder/how-i-secured-my-containerized-application-using-anchore-day-29-project-474l)
#   ‚Ä¢ Unexpected EOF in jq: ensure jq blocks use double quotes.
#   ‚Ä¢ No SBOM/vulns: verify Syft/Grype install succeeded.
#
# Safe edits
#   ‚Ä¢ PR workflows always run using the workflow from the base branch (main);
#     merge workflow edits first for them to take effect.  [1](https://deepwiki.com/anchore/grype/5.2-release-pipeline)
#
# Ownership
#   ‚Ä¢ Maintainer: Quality & Regulatory / Security (QRA)
#   ‚Ä¢ Contact: <your team or channel>
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# SBOM & Risk Report (Dependabot-only) ‚Äî Option B: scan BASE + HEAD
# ---------------------------------------------------------------------------

name: SBOM & Risk Report (Dependabot)

on:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

jobs:
  sbom_and_risk:
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Use the official metadata action for Dependabot PR context
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # ------------------------------
      # 1) Install Syft
      # ------------------------------
      - name: Install Syft
        run: |
          curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin

      # ------------------------------
      # 2) Prepare BASE worktree and generate SBOMs for BASE & HEAD
      # ------------------------------
      # NEW/CHANGED: we now generate sbom_base.json and sbom_head.json
      - name: Prepare BASE worktree
        run: |
          git worktree add --detach /tmp/base "${{ github.event.pull_request.base.sha }}"

      - name: Generate SBOM (CycloneDX JSON) ‚Äî BASE
        run: syft dir:/tmp/base -o cyclonedx-json > sbom_base.json

      - name: Generate SBOM (CycloneDX JSON) ‚Äî HEAD
        run: syft dir:. -o cyclonedx-json > sbom_head.json

      # ------------------------------
      # 3) Install Grype and scan both SBOMs
      # ------------------------------
      - name: Install Grype
        run: |
          curl -sSfL https://get.anchore.io/grype | sudo sh -s -- -b /usr/local/bin

      # NEW/CHANGED: produce grype_base.json and grype_head.json
      - name: Run vulnerability scans (Grype) ‚Äî BASE & HEAD
        run: |
          grype sbom:sbom_base.json -o json > grype_base.json || true
          grype sbom:sbom_head.json -o json > grype_head.json || true

          echo "---- BASE (first 50 lines) ----"
          grype sbom:sbom_base.json -o table | head -n 50 || true
          echo "---- HEAD (first 50 lines) ----"
          grype sbom:sbom_head.json -o table | head -n 50 || true

      # ------------------------------
      # 4) Dependency updates (file list only)
      # ------------------------------
      - name: Extract dependency updates from PR diff
        run: |
          echo "## üì¶ Dependency Updates" > updates.md

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          git diff --name-only "$BASE_SHA" "$HEAD_SHA" > changed_files.txt

          DEP_FILES=$(grep -E '(package.json|package-lock.json|Gemfile|Gemfile.lock|requirements|Pipfile|poetry.lock|pyproject.toml|go.mod|go.sum|Cargo.lock|composer.lock)' changed_files.txt || true)

          if [ -z "$DEP_FILES" ]; then
            echo "_No dependency manifest or lockfile changes detected._" >> updates.md
          else
            echo "**Changed dependency files:**" >> updates.md
            echo "" >> updates.md
            echo "$DEP_FILES" | sed 's/^/- `/' | sed 's/$/`/' >> updates.md
          fi

      # ------------------------------
      # 5) HEAD-only: Severity summary + per-severity tables
      # ------------------------------
      # NEW/CHANGED: run summaries from grype_head.json (remaining vulns after the PR)
      - name: Build severity summary (HEAD)
        run: |
          jq "
            [.matches[].vulnerability.severity]
            | group_by(.)
            | map({severity: .[0], count: length})
            | sort_by(.severity)
            | reverse
          " grype_head.json > /tmp/severity_counts.json

          echo "## üßÆ Severity Summary (after this PR)" > severity.md
          echo "| Severity | Count |" >> severity.md
          echo "|---|---:|" >> severity.md
          jq -r '.[] | "| \(.severity) | \(.count) |"' /tmp/severity_counts.json >> severity.md

      - name: Extract vulnerabilities by severity (HEAD)
        run: |
          make_table() {
            local severity="$1"
            local outfile="$2"

            jq "
              [.matches[]
                | select(.vulnerability.severity==\"${severity}\")
                | {
                    pkg: .artifact.name,
                    version: .artifact.version,
                    vuln: .vulnerability.id,
                    fix: (.vulnerability.fix.versions[0] // \"-\")
                  }
              ]
            " grype_head.json > "$outfile"

            local count
            count=$(jq 'length' "$outfile")

            {
              echo "## ${severity} Vulnerabilities (remaining after this PR)"
              if [ "$count" -eq 0 ]; then
                echo "_No ${severity} vulnerabilities remain._"
              else
                echo "| Package | Version | Vulnerability | Fix |"
                echo "|---|---|---|---|"
                jq -r '.[] | "| \(.pkg) | \(.version) | \(.vuln) | \(.fix) |"' "$outfile"
              fi
            } > "${outfile}.md"
          }

          make_table "Critical" "/tmp/critical_list.json"
          make_table "High"     "/tmp/high_list.json"
          make_table "Medium"   "/tmp/medium_list.json"

          mv /tmp/critical_list.json.md critical.md
          mv /tmp/high_list.json.md     high.md
          mv /tmp/medium_list.json.md   medium.md

      # ------------------------------
      # 6) DIFF BASE vs HEAD: Fixed-by-this-PR and Introduced-by-this-PR
      # ------------------------------
      # NEW: normalized tuple: name|version|vuln|severity|fixver
      - name: Compute resolved/new vulnerability sets
        run: |
          norm() {
            local file="$1"
            jq -r '
              .matches[]
              | [
                  (.artifact.name // "-"),
                  (.artifact.version // "-"),
                  (.vulnerability.id // "-"),
                  (.vulnerability.severity // "-"),
                  (.vulnerability.fix.versions[0] // "-")
                ] | join("|")
            ' "$file" | sort -u
          }

          norm grype_base.json > /tmp/base.txt || true
          norm grype_head.json > /tmp/head.txt || true

          # Resolved = present in BASE but not in HEAD
          comm -23 /tmp/base.txt /tmp/head.txt > /tmp/resolved.txt || true
          # New = present in HEAD but not in BASE
          comm -13 /tmp/base.txt /tmp/head.txt > /tmp/new.txt || true

          # Build "Resolved by this PR"
          {
            echo "## ‚úÖ Vulnerabilities fixed by this PR"
            if [ -s /tmp/resolved.txt ]; then
              echo "| Package | Old Version | Vulnerability | Severity | Fix Version |"
              echo "|---|---|---|---|---|"
              awk -F'|' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' /tmp/resolved.txt
            else
              echo "_No vulnerabilities were fixed by this PR (none were present in BASE)._"
            fi
          } > resolved.md

          # Build "Newly introduced"
          {
            echo "## üß© New vulnerabilities introduced by this PR"
            if [ -s /tmp/new.txt ]; then
              echo "| Package | Version | Vulnerability | Severity | Fix Version |"
              echo "|---|---|---|---|---|"
              awk -F'|' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' /tmp/new.txt
            else
              echo "_No new vulnerabilities introduced by this PR._"
            fi
          } > new_vulns.md

      # ------------------------------
      # 7) SBOM summary (HEAD, unique components)
      # ------------------------------
      - name: SBOM summary (first 100 unique components, HEAD)
        run: |
          echo "## üßæ SBOM (HEAD, first 100 unique components)" > sbom.md
          echo "_Full SBOMs attached as artifacts (sbom_base.json, sbom_head.json)._ " >> sbom.md
          echo "" >> sbom.md
          echo "| Component | Version | License |" >> sbom.md
          echo "|---|---|---|" >> sbom.md

          jq '
            (.components // [])
            | map({
                name: (.name // "-"),
                version: (.version // "-"),
                license: (
                  ( .licenses[0].license.name ) //
                  ( .licenses[0].expression ) //
                  ( .properties[]? | select(.name=="syft:metadata:package:license") | .value ) //
                  "-"
                )
              })
            | unique_by(.name + ":" + .version)
            | .[0:100]
          ' sbom_head.json \
          | jq -r '.[] | "| \(.name) | \(.version) | \(.license) |"' >> sbom.md

      # ------------------------------
      # 8) Latest Available Versions ‚Äî FINAL FIXED VERSION
      # ------------------------------
      - name: Build dependency latest-version table
        shell: bash
        run: |
          set -euo pipefail

          echo "## üìå Latest Available Versions" > latest.md
          echo "" >> latest.md
          echo "| Package | Current | Latest | Ecosystem | Update |" >> latest.md
          echo "|---|---|---|---|---|" >> latest.md

          PKGS="${{ steps.metadata.outputs.dependency-names }}"
          ECO="${{ steps.metadata.outputs.package-ecosystem }}"
          TYPE="${{ steps.metadata.outputs.update-type }}"
          OLD_META="${{ steps.metadata.outputs.previous-version }}"
          NEW_META="${{ steps.metadata.outputs.new-version }}"

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          git diff --name-only "$BASE_SHA" "$HEAD_SHA" > /tmp/changed_files.txt || true

          # Normalize DEP_FILES: remove quotes, whitespace, blank lines
          DEP_FILES=$(grep -E 'Gemfile.lock|package-lock.json|npm-shrinkwrap.json' /tmp/changed_files.txt \
            | sed 's/^ *//' | sed 's/ *$//' | tr -d '"' | sed '/^$/d' || true)

          parse_bundler_map () {
            awk '
              /^[[:space:]]+[A-Za-z0-9_.\-]+ \([0-9][^)]*\)/ {
                line=$0
                sub(/^[ \t]+/,"",line)
                name=line
                sub(/ .*/,"",name)
                ver=line
                sub(/^[^ ]+ \(/,"",ver)
                sub(/\).*/,"",ver)
                print name " " ver
              }
            '
          }

          parse_npm_map () {
            jq -r '
              if has("packages") then
                (.packages | to_entries[]
                  | select(.key | startswith("node_modules/"))
                  | {n: (.key | sub("^node_modules/"; "")), v: (.value.version // empty)}
                )
              else
                (.dependencies // {} | to_entries[]
                  | {n: .key, v: (.value.version // empty)}
                )
              end
              | select(.v != null and .v != "")
              | "\(.n) \(.v)"
            '
          }

          rows_generated=0

          # iterate through normalized file list
          while IFS= read -r f; do
            [[ -z "$f" ]] && continue

            case "$f" in
              */Gemfile.lock|Gemfile.lock)
                git show "${BASE_SHA}:${f}" > /tmp/base.lock 2>/dev/null || continue
                git show "${HEAD_SHA}:${f}" > /tmp/head.lock 2>/dev/null || continue

                parse_bundler_map < /tmp/base.lock | sort -u > /tmp/base.map
                parse_bundler_map < /tmp/head.lock | sort -u > /tmp/head.map

                join -a1 -a2 -e "-" -o auto -j 1 \
                  <(sort /tmp/base.map) \
                  <(sort /tmp/head.map) \
                | awk '{if ($2 != $3) print $1, $2, $3}' \
                | while read -r name oldver newver; do
                    echo "| $name | $oldver | $newver | bundler | ${TYPE:-version-update:unknown} |" >> latest.md
                    rows_generated=$((rows_generated+1))
                  done
                ;;

              */package-lock.json|package-lock.json|*/npm-shrinkwrap.json|npm-shrinkwrap.json)
                git show "${BASE_SHA}:${f}" > /tmp/base.lock 2>/dev/null || continue
                git show "${HEAD_SHA}:${f}" > /tmp/head.lock 2>/dev/null || continue

                parse_npm_map < /tmp/base.lock | sort -u > /tmp/base.map
                parse_npm_map < /tmp/head.lock | sort -u > /tmp/head.map

                join -a1 -a2 -e "-" -o auto -j 1 \
                  <(sort /tmp/base.map) \
                  <(sort /tmp/head.map) \
                | awk '{if ($2 != $3) print $1, $2, $3}' \
                | while read -r name oldver newver; do
                    echo "| $name | $oldver | $newver | npm | ${TYPE:-version-update:unknown} |" >> latest.md
                    rows_generated=$((rows_generated+1))
                  done
                ;;
            esac
          done <<< "$DEP_FILES"

          # Fallback only when ABSOLUTELY no diff rows exist
          if [[ "$rows_generated" -eq 0 ]]; then
            if [[ -n "$NEW_META" || -n "$OLD_META" ]]; then
              echo "| ${PKGS:-'-'} | ${OLD_META:-'-'} | ${NEW_META:-'-'} | ${ECO:-'-'} | ${TYPE:-'-'} |" >> latest.md

            elif [[ -n "$PKGS" ]]; then
              IFS=',' read -ra NAMES <<< "$PKGS"
              for n in "${NAMES[@]}"; do
                name_trimmed=$(echo "$n" | xargs)
                echo "| ${name_trimmed} | - | - | ${ECO:-'-'} | ${TYPE:-'-'} |" >> latest.md
              done

            else
              echo "_No dependency metadata available._" >> latest.md
            fi
          fi
      # ------------------------------
      # 9) Assemble PR comment
      # ------------------------------
      - name: Assemble PR comment
        run: |
          {
            echo "## üîí Dependency Risk Report (Dependabot)"
            echo "**PR:** #${{ github.event.pull_request.number }}"
            echo ""

            # Option B sections (BASE vs HEAD)
            cat resolved.md
            echo ""
            cat new_vulns.md
            echo ""

            # HEAD-only summaries
            cat severity.md
            echo ""
            cat critical.md
            echo ""
            cat high.md
            echo ""
            cat medium.md
            echo ""

            # Dependency updates + metadata
            cat updates.md
            echo ""
            cat latest.md
            echo ""

            # SBOM preview
            echo "<details><summary>SBOM (HEAD, first 100 unique components)</summary>"
            echo ""
            cat sbom.md
            echo ""
            echo "</details>"
          } > report.md

      - name: Post PR comment
        uses: mshick/add-pr-comment@v2
        with:
          message-path: report.md

      # ------------------------------
      # 10) Upload artifacts (BASE & HEAD)
      # ------------------------------
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-and-risk-report
          path: |
            sbom_base.json
            sbom_head.json
            grype_base.json
            grype_head.json
            report.md
